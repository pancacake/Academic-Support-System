<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº¤äº’å¼æ€ç»´å¯¼å›¾ - Academic Support System</title>
    {% load static %}
    {% csrf_token %}
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 25%, #0f3460 50%, #533483 75%, #2d1b69 100%);
            min-height: 100vh;
            color: #e8eaed;
            margin: 0;
            padding: 0;
            position: relative;
        }

        /* æ·»åŠ åŠ¨æ€èƒŒæ™¯ç²’å­æ•ˆæœ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.08) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
            animation: backgroundShift 20s ease-in-out infinite;
        }

        @keyframes backgroundShift {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .topbar {
            background: rgba(47, 47, 47, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 32px rgba(0, 0, 0, 0.3);
        }
        
        .sysname {
            font-size: 1.2rem;
            font-weight: 600;
            color: #ffffff;
        }

        .main-layout {
            display: flex;
            height: calc(100vh - 70px);
        }

        .sidebar {
            width: 60px;
            background: rgba(26, 26, 26, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            z-index: 50;
            box-shadow: 4px 0 32px rgba(0, 0, 0, 0.2);
        }

        .sidebar:hover {
            width: 200px;
        }

        .sidebar-item {
            width: calc(100% - 1rem);
            display: flex;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #999;
            text-decoration: none;
            border-radius: 0.5rem;
            margin: 0 0.5rem 0.5rem 0.5rem;
        }

        /* é»˜è®¤çŠ¶æ€ä¸‹å›¾æ ‡å±…ä¸­ */
        .sidebar-item .sidebar-icon {
            margin: 0 auto;
        }

        /* å±•å¼€æ—¶å›¾æ ‡å·¦å¯¹é½ */
        .sidebar:hover .sidebar-item .sidebar-icon {
            margin: 0;
        }

        .sidebar-item:hover {
            background: #333;
            color: #e8eaed;
        }

        .sidebar-item.active {
            background: #0084ff;
            color: white;
        }

        .sidebar-icon {
            font-size: 1.2rem;
            min-width: 24px;
            text-align: center;
        }

        .sidebar-text {
            margin-left: 1rem;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar:hover .sidebar-text {
            opacity: 1;
        }
        
        .nav-links {
            display: flex;
            gap: 1rem;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .nav-link:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .container {
            display: flex;
            flex: 1;
            padding: 1rem;
            gap: 1rem;
        }
        
        .mindmap-sidebar {
            width: 300px;
            background: #2f2f2f;
            border-right: 1px solid #404040;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .mindmap-container {
            flex: 1;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 50%, #1a1a2e 100%);
            position: relative;
            overflow: hidden;
            border-radius: 1rem;
            margin: 1rem;
            margin-left: 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .sidebar h3 {
            margin-bottom: 1rem;
            color: #90caf9;
            font-size: 1.2rem;
        }
        
        .control-group {
            margin-bottom: 1.5rem;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        .btn {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: none;
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 0.75rem;
        }

        .btn:hover::before {
            opacity: 1;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn.primary {
            background: linear-gradient(135deg, #0084ff, #0066cc);
            border-color: rgba(0, 132, 255, 0.3);
            box-shadow: 0 4px 16px rgba(0, 132, 255, 0.3);
        }

        .btn.primary:hover {
            box-shadow: 0 8px 25px rgba(0, 132, 255, 0.4);
        }
        
        .status {
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        
        .status.info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid rgba(33, 150, 243, 0.3);
        }
        
        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        
        #mindmap-svg {
            width: 100%;
            height: 100%;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node text {
            font-family: inherit;
            font-size: 14px;
            fill: #ffffff;
            text-anchor: start;  /* ç¡®ä¿æ–‡å­—å·¦å¯¹é½ */
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
            /* æ”¹å–„æ–‡å­—æ¸²æŸ“è´¨é‡ */
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            /* é˜²æ­¢æ–‡å­—è¢«æˆªæ–­ */
            white-space: nowrap;
            overflow: visible;
        }

        .node-point {
            pointer-events: none;
        }
        
        .link {
            fill: none;
            stroke: rgba(255, 255, 255, 0.6);
            stroke-width: 2px;
        }
        
        .context-menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 0.5rem;
            padding: 0.5rem 0;
            min-width: 150px;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        .context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 0.9rem;
        }
        
        .context-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .node-editor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 2rem;
            border-radius: 1rem;
            min-width: 300px;
            z-index: 1001;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        .node-editor input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            margin-bottom: 1rem;
        }
        
        .node-editor input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .node-editor .btn-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .node-editor .btn {
            flex: 1;
            margin-bottom: 0;
        }

        /* å¸ƒå±€æ¨¡å¼é€‰æ‹©å™¨ */
        .layout-modes {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .layout-mode {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .layout-mode:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(2px);
        }

        .layout-mode.active {
            background: rgba(0, 132, 255, 0.2);
            border-color: rgba(0, 132, 255, 0.4);
            color: #4fc3f7;
        }

        .layout-icon {
            width: 24px;
            height: 24px;
            margin-right: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: inherit;
        }

        .layout-icon svg {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="topbar">
        <div class="sysname">çŸ¥æ‚ŸÂ·å¯æ˜å­¦ä¸šé—®ç­”ç³»ç»Ÿ - æ€ç»´å¯¼å›¾</div>
        <div class="nav-links">
            <a href="#" class="nav-link" onclick="exportMindmap()">å¯¼å‡ºJSON</a>
            <a href="#" class="nav-link" onclick="exportAsPNG()">å¯¼å‡ºå›¾ç‰‡</a>
            <span id="userStatus" style="color: #e8eaed; margin-left: 1rem;">æ¬¢è¿ä½¿ç”¨å­¦æœ¯æ”¯æŒç³»ç»Ÿ</span>
            <a href="/users/login/" id="loginLink" style="color: #4fc3f7; text-decoration: none; margin-left: 1rem; padding: 0.5rem 1rem; background: rgba(79, 195, 247, 0.1); border-radius: 0.5rem; border: 1px solid rgba(79, 195, 247, 0.3); transition: all 0.3s ease;" onmouseover="this.style.background='rgba(79, 195, 247, 0.2)'" onmouseout="this.style.background='rgba(79, 195, 247, 0.1)'">ç™»å½•</a>
        </div>
    </div>

    <div class="main-layout">
        <div class="sidebar">
            <a href="/" class="sidebar-item">
                <div class="sidebar-icon">ğŸ’¬</div>
                <div class="sidebar-text">èŠå¤©</div>
            </a>
            <a href="/mindmap/" class="sidebar-item active">
                <div class="sidebar-icon">ğŸ§ </div>
                <div class="sidebar-text">æ€ç»´å¯¼å›¾</div>
            </a>
            <a href="/questions/" class="sidebar-item">
                <div class="sidebar-icon">ğŸ“</div>
                <div class="sidebar-text">æ™ºèƒ½å‡ºé¢˜</div>
            </a>
        </div>

        <div class="container">
        <div class="mindmap-sidebar">
            <h3>ğŸ§  æ€ç»´å¯¼å›¾æ§åˆ¶</h3>
            
            <div class="control-group">
                <button class="btn primary" onclick="console.log('æŒ‰é’®è¢«ç‚¹å‡»'); loadLatestNotes()">ğŸ“š åŠ è½½æœ€æ–°ç¬”è®°</button>
                <button class="btn" onclick="resetView()">ğŸ”„ é‡ç½®è§†å›¾</button>
                <button class="btn" onclick="resetLayout()" style="background-color: #ff6b6b;">ğŸ¯ é‡æ–°æ•´ç†å¸ƒå±€</button>
                <button class="btn" onclick="expandAll()">ğŸ“– å±•å¼€å…¨éƒ¨</button>
                <button class="btn" onclick="collapseAll()">ğŸ“• æ”¶èµ·å…¨éƒ¨</button>
            </div>

            <div class="control-group">
                <h4 style="margin-bottom: 0.75rem; font-size: 0.9rem; color: #e8eaed;">ğŸ” æœç´¢èŠ‚ç‚¹</h4>
                <input type="text" id="search-input" placeholder="è¾“å…¥å…³é”®è¯æœç´¢èŠ‚ç‚¹..."
                       style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 6px; background: #333; color: #fff; margin-bottom: 0.5rem;"
                       onkeyup="searchNodes(this.value)">
                <button class="btn" onclick="clearSearch()">æ¸…é™¤æœç´¢</button>
            </div>

            <div class="control-group">
                <h4 style="margin-bottom: 0.75rem; font-size: 0.9rem; color: #e8eaed;">ğŸ¨ å¸ƒå±€æ¨¡å¼</h4>
                <div class="layout-modes">
                    <div class="layout-mode" onclick="setLayoutMode('horizontal')" data-mode="horizontal">
                        <div class="layout-icon">
                            <svg width="24" height="16" viewBox="0 0 24 16" fill="none">
                                <circle cx="4" cy="8" r="2" fill="currentColor"/>
                                <circle cx="12" cy="4" r="2" fill="currentColor"/>
                                <circle cx="12" cy="12" r="2" fill="currentColor"/>
                                <circle cx="20" cy="8" r="2" fill="currentColor"/>
                                <line x1="6" y1="8" x2="10" y2="4" stroke="currentColor" stroke-width="1"/>
                                <line x1="6" y1="8" x2="10" y2="12" stroke="currentColor" stroke-width="1"/>
                                <line x1="14" y1="4" x2="18" y2="8" stroke="currentColor" stroke-width="1"/>
                                <line x1="14" y1="12" x2="18" y2="8" stroke="currentColor" stroke-width="1"/>
                            </svg>
                        </div>
                        <span>æ°´å¹³æ ‘çŠ¶</span>
                    </div>
                    <div class="layout-mode" onclick="setLayoutMode('vertical')" data-mode="vertical">
                        <div class="layout-icon">
                            <svg width="16" height="24" viewBox="0 0 16 24" fill="none">
                                <circle cx="8" cy="4" r="2" fill="currentColor"/>
                                <circle cx="4" cy="12" r="2" fill="currentColor"/>
                                <circle cx="12" cy="12" r="2" fill="currentColor"/>
                                <circle cx="8" cy="20" r="2" fill="currentColor"/>
                                <line x1="8" y1="6" x2="4" y2="10" stroke="currentColor" stroke-width="1"/>
                                <line x1="8" y1="6" x2="12" y2="10" stroke="currentColor" stroke-width="1"/>
                                <line x1="4" y1="14" x2="8" y2="18" stroke="currentColor" stroke-width="1"/>
                                <line x1="12" y1="14" x2="8" y2="18" stroke="currentColor" stroke-width="1"/>
                            </svg>
                        </div>
                        <span>å‚ç›´æ ‘çŠ¶</span>
                    </div>
                    <div class="layout-mode active" onclick="setLayoutMode('radial')" data-mode="radial">
                        <div class="layout-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <circle cx="12" cy="12" r="2" fill="currentColor"/>
                                <circle cx="12" cy="4" r="1.5" fill="currentColor"/>
                                <circle cx="20" cy="12" r="1.5" fill="currentColor"/>
                                <circle cx="12" cy="20" r="1.5" fill="currentColor"/>
                                <circle cx="4" cy="12" r="1.5" fill="currentColor"/>
                                <line x1="12" y1="10" x2="12" y2="5.5" stroke="currentColor" stroke-width="1"/>
                                <line x1="14" y1="12" x2="18.5" y2="12" stroke="currentColor" stroke-width="1"/>
                                <line x1="12" y1="14" x2="12" y2="18.5" stroke="currentColor" stroke-width="1"/>
                                <line x1="10" y1="12" x2="5.5" y2="12" stroke="currentColor" stroke-width="1"/>
                            </svg>
                        </div>
                        <span>è¾å°„çŠ¶</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h4 style="margin-bottom: 0.75rem; font-size: 0.9rem; color: #e8eaed;">ğŸ¨ èŠ‚ç‚¹æ ·å¼</h4>
                <p style="font-size: 0.85rem; color: #999; line-height: 1.4;">
                    å³é”®ç‚¹å‡»ä»»æ„èŠ‚ç‚¹ï¼Œé€‰æ‹©"ç¼–è¾‘æ ·å¼"æ¥è‡ªå®šä¹‰è¯¥èŠ‚ç‚¹çš„é¢œè‰²ã€å­—ä½“å¤§å°ã€ç²—ç»†å’Œæ–œä½“ç­‰æ ·å¼ã€‚
                </p>
            </div>

            <div id="status" class="status info">
                ç‚¹å‡»"åŠ è½½æœ€æ–°ç¬”è®°"å¼€å§‹ç”Ÿæˆæ€ç»´å¯¼å›¾
            </div>
            
            <div class="control-group">
                <h4 style="margin-bottom: 0.5rem;">ğŸ“– æ“ä½œè¯´æ˜</h4>
                <ul style="font-size: 0.85rem; line-height: 1.6; padding-left: 1rem; color: #ccc;">
                    <li><strong>ç‚¹å‡»èŠ‚ç‚¹</strong>ï¼šå±•å¼€/æ”¶èµ·å­èŠ‚ç‚¹</li>
                    <li><strong>åŒå‡»èŠ‚ç‚¹</strong>ï¼šå¿«é€Ÿç¼–è¾‘èŠ‚ç‚¹åç§°</li>
                    <li><strong>å³é”®èŠ‚ç‚¹</strong>ï¼šæ‰“å¼€èœå•è¿›è¡Œç¼–è¾‘ã€æ ·å¼è®¾ç½®ç­‰</li>
                    <li><strong>æ‹–æ‹½èŠ‚ç‚¹</strong>ï¼šè°ƒæ•´èŠ‚ç‚¹ä½ç½®</li>
                    <li><strong>æœç´¢åŠŸèƒ½</strong>ï¼šè¾“å…¥å…³é”®è¯é«˜äº®åŒ¹é…èŠ‚ç‚¹</li>
                    <li><strong>æ»šè½®ç¼©æ”¾</strong>ï¼šæ”¾å¤§/ç¼©å°æ€ç»´å¯¼å›¾</li>
                </ul>
                <h5 style="margin: 1rem 0 0.5rem 0; font-size: 0.8rem; color: #999;">âŒ¨ï¸ å¿«æ·é”®</h5>
                <ul style="font-size: 0.8rem; line-height: 1.4; padding-left: 1rem; color: #999;">
                    <li><strong>Ctrl+L</strong>ï¼šåŠ è½½æœ€æ–°ç¬”è®°</li>
                    <li><strong>Ctrl+E</strong>ï¼šå±•å¼€å…¨éƒ¨èŠ‚ç‚¹</li>
                    <li><strong>Ctrl+R</strong>ï¼šæ”¶èµ·å…¨éƒ¨èŠ‚ç‚¹</li>
                    <li><strong>Ctrl+F</strong>ï¼šèšç„¦æœç´¢æ¡†</li>
                    <li><strong>Esc</strong>ï¼šæ¸…é™¤æœç´¢é«˜äº®</li>
                </ul>
            </div>
        </div>
        
        <div class="mindmap-container">
            <div id="loading" class="loading" style="display: none;">
                <div class="spinner"></div>
                æ­£åœ¨ç”Ÿæˆæ€ç»´å¯¼å›¾...
            </div>
            <svg id="mindmap-svg"></svg>
        </div>
    </div>
    </div>

    <!-- å³é”®èœå• -->
    <div id="context-menu" class="context-menu">
        <div class="context-menu-item" onclick="editNode()">âœï¸ ç¼–è¾‘èŠ‚ç‚¹</div>
        <div class="context-menu-item" onclick="editNodeStyle()">ğŸ¨ ç¼–è¾‘æ ·å¼</div>
        <div class="context-menu-item" onclick="addChildNode()">â• æ·»åŠ å­èŠ‚ç‚¹</div>
        <div class="context-menu-item" onclick="deleteNode()">ğŸ—‘ï¸ åˆ é™¤èŠ‚ç‚¹</div>
        <div class="context-menu-item" onclick="generateAIContent()">ğŸ¤– AIä¼˜åŒ–</div>
    </div>
    
    <!-- èŠ‚ç‚¹ç¼–è¾‘å™¨ -->
    <div id="node-editor" class="node-editor">
        <h4 style="margin-bottom: 1rem;">ç¼–è¾‘èŠ‚ç‚¹</h4>
        <input type="text" id="node-name-input" placeholder="è¾“å…¥èŠ‚ç‚¹åç§°">
        <div class="btn-group">
            <button class="btn primary" onclick="saveNodeEdit()">ä¿å­˜</button>
            <button class="btn" onclick="cancelNodeEdit()">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- èŠ‚ç‚¹æ ·å¼ç¼–è¾‘å™¨ -->
    <div id="node-style-editor" class="node-editor" style="display: none;">
        <h4 style="margin-bottom: 1rem;">ğŸ¨ ç¼–è¾‘èŠ‚ç‚¹æ ·å¼</h4>

        <div style="margin-bottom: 1rem;">
            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.9rem;">æ–‡å­—é¢œè‰²</label>
            <input type="color" id="node-text-color" value="#ffffff" style="width: 100%; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
        </div>

        <div style="margin-bottom: 1rem;">
            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.9rem;">å­—ä½“å¤§å°</label>
            <input type="range" id="node-font-size" min="10" max="24" value="14" style="width: 100%;">
            <span id="node-font-size-value" style="font-size: 0.8rem; color: #999;">14px</span>
        </div>

        <div style="margin-bottom: 1rem;">
            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.9rem;">å­—ä½“ç²—ç»†</label>
            <select id="node-font-weight" style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 6px; background: #333; color: #fff;">
                <option value="normal">æ­£å¸¸</option>
                <option value="bold">ç²—ä½“</option>
                <option value="lighter">ç»†ä½“</option>
            </select>
        </div>

        <div style="margin-bottom: 1rem;">
            <label style="display: flex; align-items: center; font-size: 0.9rem;">
                <input type="checkbox" id="node-font-italic" style="margin-right: 0.5rem;">
                æ–œä½“
            </label>
        </div>

        <div style="margin-bottom: 1rem;">
            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.9rem;">åº•çº¿é¢œè‰²</label>
            <input type="color" id="node-underline-color" value="#81c784" style="width: 100%; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
        </div>

        <div class="btn-group">
            <button class="btn primary" onclick="saveNodeStyle()">ä¿å­˜æ ·å¼</button>
            <button class="btn" onclick="cancelNodeStyleEdit()">å–æ¶ˆ</button>
        </div>
    </div>
    
    <script>
        // å…¨å±€å˜é‡
        let mindmapData = null;
        let currentNode = null;
        let svg, g, tree, root;
        let width = 800, height = 600;
        let currentLayout = 'horizontal'; // 'horizontal', 'vertical', 'radial'
        let nodeColors = ['#0084ff', '#ff6b35', '#4CAF50', '#9C27B0', '#FF9800', '#F44336'];
        let i = 0; // èŠ‚ç‚¹IDè®¡æ•°å™¨
        let isPerformanceMode = false; // æ€§èƒ½æ¨¡å¼æ ‡å¿—
        
        // åˆå§‹åŒ–SVG
        function initSVG() {
            const container = document.querySelector('.mindmap-container');
            width = container.clientWidth;
            height = container.clientHeight;

            svg = d3.select("#mindmap-svg")
                .attr("width", width)
                .attr("height", height);
            g = svg.append("g");

            // æ·»åŠ ç¼©æ”¾å’Œæ‹–æ‹½
            const zoom = d3.zoom()
                .scaleExtent([0.1, 3])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });

            svg.call(zoom);

            // åˆå§‹åŒ–æ ‘å¸ƒå±€
            tree = d3.tree().size([height - 100, width - 200]);
        }
        
        // è®¾ç½®å¸ƒå±€æ¨¡å¼
        function setLayoutMode(mode) {
            currentLayout = mode;

            // æ›´æ–°UIçŠ¶æ€
            document.querySelectorAll('.layout-mode').forEach(el => {
                el.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');

            // é‡æ–°æ¸²æŸ“æ€ç»´å¯¼å›¾
            if (mindmapData) {
                renderMindmap(mindmapData);
            }
        }

        // è·å–èŠ‚ç‚¹é¢œè‰²
        function getNodeColor(depth) {
            return nodeColors[depth % nodeColors.length];
        }

        // æ£€æŸ¥ç”¨æˆ·ç™»å½•çŠ¶æ€
        async function checkUserStatus() {
            try {
                const response = await fetch('/users/api/current-user/');
                const data = await response.json();

                if (data.success && data.user.is_authenticated) {
                    document.getElementById('userStatus').textContent = `æ¬¢è¿ï¼Œ${data.user.username}`;
                    document.getElementById('loginLink').textContent = 'é€€å‡º';
                    document.getElementById('loginLink').href = '#';
                    document.getElementById('loginLink').onclick = logout;
                } else {
                    document.getElementById('userStatus').textContent = 'æ¸¸å®¢æ¨¡å¼';
                    document.getElementById('loginLink').textContent = 'ç™»å½•';
                    document.getElementById('loginLink').href = '/users/login/';
                    document.getElementById('loginLink').onclick = null;
                }
            } catch (error) {
                console.error('æ£€æŸ¥ç”¨æˆ·çŠ¶æ€å¤±è´¥:', error);
            }
        }

        // é€€å‡ºç™»å½•
        async function logout() {
            try {
                const response = await fetch('/users/api/logout/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const data = await response.json();
                if (data.success) {
                    window.location.reload();
                }
            } catch (error) {
                console.error('é€€å‡ºç™»å½•å¤±è´¥:', error);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
            initSVG();
            updateStatus('å‡†å¤‡å°±ç»ª', 'info');
            checkUserStatus();

            // æµ‹è¯•å‡½æ•°æ˜¯å¦å¯ç”¨
            console.log('loadLatestNoteså‡½æ•°:', typeof loadLatestNotes);
            console.log('updateStatuså‡½æ•°:', typeof updateStatus);

            // å°†å‡½æ•°æ·»åŠ åˆ°å…¨å±€windowå¯¹è±¡ï¼Œç¡®ä¿å¯ä»¥è¢«onclickè®¿é—®
            window.loadLatestNotes = loadLatestNotes;

            // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
            document.addEventListener('keydown', function(event) {
                // Ctrl+L: åŠ è½½æœ€æ–°ç¬”è®°
                if (event.ctrlKey && event.key === 'l') {
                    event.preventDefault();
                    loadLatestNotes();
                }
                // Ctrl+E: å±•å¼€å…¨éƒ¨
                else if (event.ctrlKey && event.key === 'e') {
                    event.preventDefault();
                    expandAll();
                }
                // Ctrl+R: æ”¶èµ·å…¨éƒ¨
                else if (event.ctrlKey && event.key === 'r') {
                    event.preventDefault();
                    collapseAll();
                }
                // Ctrl+F: èšç„¦æœç´¢æ¡†
                else if (event.ctrlKey && event.key === 'f') {
                    event.preventDefault();
                    document.getElementById('search-input').focus();
                }
                // Escape: æ¸…é™¤æœç´¢
                else if (event.key === 'Escape') {
                    clearSearch();
                }
            });
        });

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }

        // åŠ è½½æœ€æ–°ç¬”è®° - ç§»åˆ°å…¨å±€ä½œç”¨åŸŸ
        async function loadLatestNotes() {
            console.log('å¼€å§‹åŠ è½½æœ€æ–°ç¬”è®°...');
            try {
                updateStatus('æ­£åœ¨åŠ è½½æœ€æ–°ç¬”è®°...', 'info');
                document.getElementById('loading').style.display = 'flex';

                console.log('å‘é€è¯·æ±‚åˆ°: /api/mindmap/latest-notes/');
                const response = await fetch('/api/mindmap/latest-notes/');
                console.log('å“åº”çŠ¶æ€:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTPé”™è¯¯: ${response.status}`);
                }

                const data = await response.json();
                console.log('è·å–åˆ°çš„æ•°æ®:', data);

                if (!data.success) {
                    throw new Error(data.error);
                }

                console.log('å¼€å§‹è§£æç¬”è®°å†…å®¹...');
                // è§£æç¬”è®°ä¸ºæ€ç»´å¯¼å›¾
                const parseResponse = await fetch('/api/mindmap/parse/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken') || ''
                    },
                    body: JSON.stringify({
                        content: data.content
                    })
                });

                console.log('è§£æå“åº”çŠ¶æ€:', parseResponse.status);

                if (!parseResponse.ok) {
                    throw new Error(`è§£æè¯·æ±‚å¤±è´¥: ${parseResponse.status}`);
                }

                const parseData = await parseResponse.json();
                console.log('è§£æç»“æœ:', parseData);

                if (!parseData.success) {
                    throw new Error(parseData.error);
                }

                mindmapData = parseData.mindmap_data;
                console.log('æ€ç»´å¯¼å›¾æ•°æ®:', mindmapData);

                renderMindmap(mindmapData);
                updateStatus('æ€ç»´å¯¼å›¾åŠ è½½æˆåŠŸ', 'success');

            } catch (error) {
                updateStatus(`åŠ è½½å¤±è´¥: ${error.message}`, 'error');
                console.error('Error loading notes:', error);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // è·å–CSRF tokençš„è¾…åŠ©å‡½æ•°
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        // æ¸²æŸ“æ€ç»´å¯¼å›¾
        function renderMindmap(data) {
            // æ¸…é™¤ç°æœ‰å†…å®¹
            g.selectAll("*").remove();

            // ä¸ºæ¯ä¸ªèŠ‚ç‚¹æ·»åŠ é»˜è®¤æ ·å¼å±æ€§
            function addDefaultStyles(node) {
                if (!node.style) {
                    node.style = {
                        textColor: '#ffffff',
                        fontSize: 14,
                        fontWeight: 'normal',
                        fontItalic: false,
                        underlineColor: '#81c784'
                    };
                }
                if (node.children) {
                    node.children.forEach(addDefaultStyles);
                }
            }
            addDefaultStyles(data);

            // ç»Ÿè®¡èŠ‚ç‚¹æ•°é‡
            function countNodes(node) {
                let count = 1;
                if (node.children) {
                    node.children.forEach(child => {
                        count += countNodes(child);
                    });
                }
                return count;
            }
            const totalNodes = countNodes(data);

            // åˆ›å»ºå±‚æ¬¡ç»“æ„
            root = d3.hierarchy(data);
            root.x0 = height / 2;
            root.y0 = 0;

            // åˆå§‹åŒ–èŠ‚ç‚¹çŠ¶æ€
            if (root.children) {
                root.children.forEach(collapse);
            }

            update(root);

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤ºèŠ‚ç‚¹æ•°é‡
            updateStatus(`æ€ç»´å¯¼å›¾å·²åŠ è½½ï¼Œå…± ${totalNodes} ä¸ªèŠ‚ç‚¹`, 'success');
        }
        
        // æ”¶èµ·èŠ‚ç‚¹
        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }
        
        // è®¡ç®—èŠ‚ç‚¹æ–‡æœ¬å®½åº¦
        function getTextWidth(text, fontSize = 14) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `${fontSize}px -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif`;
            return context.measureText(text).width;
        }

        // è®¡ç®—åŠ¨ç”»æŒç»­æ—¶é—´
        function calculateAnimationDuration(nodeCount) {
            // æ ¹æ®èŠ‚ç‚¹æ•°é‡åŠ¨æ€è°ƒæ•´åŠ¨ç”»æ—¶é—´
            const baseDuration = 600;
            const maxDuration = 1200;
            const minDuration = 200;

            if (nodeCount <= 10) return baseDuration;
            if (nodeCount >= 100) return minDuration;

            // èŠ‚ç‚¹è¶Šå¤šï¼ŒåŠ¨ç”»è¶Šå¿«ï¼Œé¿å…ç­‰å¾…æ—¶é—´è¿‡é•¿
            const factor = 1 - (nodeCount - 10) / 90;
            return Math.max(minDuration, baseDuration * factor);
        }

        // æ€§èƒ½æ£€æµ‹å’Œä¼˜åŒ–
        function checkPerformanceMode(nodeCount) {
            const previousMode = isPerformanceMode;
            isPerformanceMode = nodeCount > 80;

            if (isPerformanceMode && !previousMode) {
                updateStatus('èŠ‚ç‚¹è¾ƒå¤šï¼Œå·²å¯ç”¨æ€§èƒ½æ¨¡å¼', 'info');
            } else if (!isPerformanceMode && previousMode) {
                updateStatus('å·²é€€å‡ºæ€§èƒ½æ¨¡å¼', 'info');
            }

            return isPerformanceMode;
        }

        // æ€§èƒ½ä¼˜åŒ–çš„èŠ‚ç‚¹æ¸²æŸ“
        function optimizeNodeRendering(nodeSelection) {
            if (isPerformanceMode) {
                // æ€§èƒ½æ¨¡å¼ï¼šç®€åŒ–æ¸²æŸ“
                nodeSelection.select('circle')
                    .style('filter', null) // ç§»é™¤é˜´å½±æ•ˆæœ
                    .style('stroke-width', 1);

                nodeSelection.select('text')
                    .style('text-shadow', null); // ç§»é™¤æ–‡å­—é˜´å½±
            } else {
                // æ­£å¸¸æ¨¡å¼ï¼šå®Œæ•´æ¸²æŸ“
                nodeSelection.select('circle')
                    .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))')
                    .style('stroke-width', 2);

                nodeSelection.select('text')
                    .style('text-shadow', '0 1px 2px rgba(0,0,0,0.1)');
            }
        }

        // è®¡ç®—åŠ¨æ€é—´è· - å…¨å±€æ™ºèƒ½è®¡ç®—
        function calculateDynamicSpacing() {
            if (!root) return { horizontal: 200, vertical: 80 };

            const allNodes = root.descendants();
            let maxTextWidth = 0;
            let avgTextWidth = 0;
            let totalWidth = 0;
            let maxDepth = 0;

            allNodes.forEach(d => {
                const fontSize = d.data.style ? d.data.style.fontSize : 14;
                const textWidth = getTextWidth(d.data.name, fontSize);
                maxTextWidth = Math.max(maxTextWidth, textWidth);
                totalWidth += textWidth;
                maxDepth = Math.max(maxDepth, d.depth);
            });

            avgTextWidth = totalWidth / allNodes.length;

            // æ™ºèƒ½é—´è·è®¡ç®—ï¼šè€ƒè™‘æ–‡æœ¬é•¿åº¦ã€èŠ‚ç‚¹æ•°é‡å’Œæ·±åº¦
            const baseHorizontal = Math.max(maxTextWidth + 120, 200);
            const baseVertical = Math.max(avgTextWidth / 4 + 50, 70);

            // æ ¹æ®èŠ‚ç‚¹æ•°é‡è°ƒæ•´é—´è·
            const nodeCountFactor = Math.min(allNodes.length / 20, 2);
            const depthFactor = Math.min(maxDepth / 5, 1.5);

            return {
                horizontal: baseHorizontal * (1 + depthFactor * 0.3),
                vertical: baseVertical * (1 + nodeCountFactor * 0.2)
            };
        }

        // å¹³è¡¡æ°´å¹³å¸ƒå±€ç®—æ³•
        function balanceHorizontalLayout(nodes) {
            // æŒ‰æ·±åº¦åˆ†ç»„èŠ‚ç‚¹
            const nodesByDepth = {};
            nodes.forEach(d => {
                if (!nodesByDepth[d.depth]) nodesByDepth[d.depth] = [];
                nodesByDepth[d.depth].push(d);
            });

            // å¯¹æ¯ä¸ªæ·±åº¦çº§åˆ«è¿›è¡Œå¹³è¡¡
            Object.keys(nodesByDepth).forEach(depth => {
                const levelNodes = nodesByDepth[depth];
                if (levelNodes.length <= 1) return;

                // æŒ‰çˆ¶èŠ‚ç‚¹åˆ†ç»„
                const nodesByParent = {};
                levelNodes.forEach(node => {
                    const parentId = node.parent ? node.parent.id || 'root' : 'root';
                    if (!nodesByParent[parentId]) nodesByParent[parentId] = [];
                    nodesByParent[parentId].push(node);
                });

                // ä¸ºæ¯ä¸ªçˆ¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åˆ›å»ºå‡åŒ€åˆ†å¸ƒ
                Object.values(nodesByParent).forEach(siblings => {
                    if (siblings.length <= 1) return;

                    // è®¡ç®—çˆ¶èŠ‚ç‚¹ä½ç½®ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                    const parentX = siblings[0].parent ? siblings[0].parent.x : height / 2;

                    // æ ¹æ®å…„å¼ŸèŠ‚ç‚¹æ•°é‡è®¡ç®—é—´è·
                    const siblingCount = siblings.length;
                    const totalSpread = Math.min(siblingCount * 80, height * 0.6); // é™åˆ¶æ€»å±•å¼€èŒƒå›´
                    const spacing = totalSpread / Math.max(siblingCount - 1, 1);

                    // è®¡ç®—èµ·å§‹ä½ç½®ï¼Œä½¿èŠ‚ç‚¹å›´ç»•çˆ¶èŠ‚ç‚¹å±…ä¸­åˆ†å¸ƒ
                    const startX = parentX - totalSpread / 2;

                    // æŒ‰åŸå§‹ä½ç½®æ’åºä»¥ä¿æŒç›¸å¯¹é¡ºåº
                    siblings.sort((a, b) => a.x - b.x);

                    // é‡æ–°åˆ†é…ä½ç½®
                    siblings.forEach((node, index) => {
                        node.x = startX + index * spacing;
                    });
                });
            });

            // æ£€æµ‹å¹¶è§£å†³è·¨çˆ¶èŠ‚ç‚¹çš„å­æ ‘é‡å 
            resolveSubtreeOverlaps(nodes);
        }

        // æ£€æµ‹å¹¶è§£å†³è·¨çˆ¶èŠ‚ç‚¹çš„å­æ ‘é‡å 
        function resolveSubtreeOverlaps(nodes) {
            // æŒ‰æ·±åº¦åˆ†ç»„èŠ‚ç‚¹
            const nodesByDepth = {};
            nodes.forEach(d => {
                if (!nodesByDepth[d.depth]) nodesByDepth[d.depth] = [];
                nodesByDepth[d.depth].push(d);
            });

            // ä»ç¬¬äºŒå±‚å¼€å§‹æ£€æŸ¥ï¼ˆç¬¬ä¸€å±‚æ˜¯æ ¹èŠ‚ç‚¹ï¼‰
            const depths = Object.keys(nodesByDepth).map(d => parseInt(d)).sort((a, b) => a - b);

            for (let i = 1; i < depths.length; i++) {
                const currentDepth = depths[i];
                const currentLevelNodes = nodesByDepth[currentDepth];

                if (currentLevelNodes.length <= 1) continue;

                // æŒ‰çˆ¶èŠ‚ç‚¹åˆ†ç»„å½“å‰å±‚çº§çš„èŠ‚ç‚¹
                const subtreesByParent = {};
                currentLevelNodes.forEach(node => {
                    const parentId = node.parent ? node.parent.id || 'root' : 'root';
                    if (!subtreesByParent[parentId]) {
                        subtreesByParent[parentId] = {
                            parent: node.parent,
                            nodes: []
                        };
                    }
                    subtreesByParent[parentId].nodes.push(node);
                });

                // è·å–æ‰€æœ‰å­æ ‘çš„è¾¹ç•Œ
                const subtrees = Object.values(subtreesByParent).map(subtree => {
                    const nodes = subtree.nodes;
                    const minX = Math.min(...nodes.map(n => n.x));
                    const maxX = Math.max(...nodes.map(n => n.x));
                    return {
                        parent: subtree.parent,
                        nodes: nodes,
                        minX: minX,
                        maxX: maxX,
                        centerX: (minX + maxX) / 2,
                        height: maxX - minX
                    };
                });

                // æŒ‰çˆ¶èŠ‚ç‚¹çš„å‚ç›´ä½ç½®æ’åºå­æ ‘
                subtrees.sort((a, b) => {
                    const aParentX = a.parent ? a.parent.x : height / 2;
                    const bParentX = b.parent ? b.parent.x : height / 2;
                    return aParentX - bParentX;
                });

                // æ£€æµ‹å¹¶è§£å†³å­æ ‘é‡å  - é€šè¿‡è°ƒæ•´çˆ¶èŠ‚ç‚¹é—´è·
                const minSubtreeGap = 40; // å­æ ‘ä¹‹é—´çš„æœ€å°é—´è·
                const parentAdjustments = []; // è®°å½•éœ€è¦è°ƒæ•´çš„çˆ¶èŠ‚ç‚¹

                for (let j = 1; j < subtrees.length; j++) {
                    const currentSubtree = subtrees[j];
                    const previousSubtree = subtrees[j - 1];

                    // æ£€æŸ¥æ˜¯å¦é‡å 
                    const overlap = previousSubtree.maxX + minSubtreeGap - currentSubtree.minX;
                    if (overlap > 0) {
                        // è®¡ç®—éœ€è¦è°ƒæ•´çˆ¶èŠ‚ç‚¹çš„è·ç¦»
                        const parentMoveDistance = overlap * 0.8; // çˆ¶èŠ‚ç‚¹ç§»åŠ¨è·ç¦»ç¨å°ä¸€äº›

                        // è®°å½•éœ€è¦è°ƒæ•´çš„çˆ¶èŠ‚ç‚¹
                        if (currentSubtree.parent) {
                            parentAdjustments.push({
                                parent: currentSubtree.parent,
                                moveDistance: parentMoveDistance,
                                subtreeIndex: j
                            });
                        }
                    }
                }

                // åº”ç”¨çˆ¶èŠ‚ç‚¹è°ƒæ•´
                parentAdjustments.forEach(adjustment => {
                    // ç§»åŠ¨çˆ¶èŠ‚ç‚¹åŠå…¶æ‰€æœ‰åç»­å…„å¼ŸèŠ‚ç‚¹
                    const parentDepth = adjustment.parent.depth;
                    const parentLevelNodes = nodesByDepth[parentDepth];

                    if (parentLevelNodes) {
                        // æŒ‰å‚ç›´ä½ç½®æ’åºçˆ¶èŠ‚ç‚¹
                        parentLevelNodes.sort((a, b) => a.x - b.x);

                        // æ‰¾åˆ°å½“å‰çˆ¶èŠ‚ç‚¹çš„ä½ç½®
                        const parentIndex = parentLevelNodes.findIndex(node => node === adjustment.parent);

                        // ç§»åŠ¨å½“å‰çˆ¶èŠ‚ç‚¹åŠå…¶åç»­æ‰€æœ‰å…„å¼ŸèŠ‚ç‚¹
                        for (let k = parentIndex; k < parentLevelNodes.length; k++) {
                            const nodeToMove = parentLevelNodes[k];
                            nodeToMove.x += adjustment.moveDistance;

                            // åŒæ—¶ç§»åŠ¨è¯¥çˆ¶èŠ‚ç‚¹çš„æ‰€æœ‰å­å­™èŠ‚ç‚¹
                            moveDescendants(nodeToMove, adjustment.moveDistance);
                        }
                    }
                });
            }
        }

        // ç§»åŠ¨èŠ‚ç‚¹çš„æ‰€æœ‰å­å­™èŠ‚ç‚¹
        function moveDescendants(node, moveDistance) {
            if (node.children) {
                node.children.forEach(child => {
                    child.x += moveDistance;
                    moveDescendants(child, moveDistance); // é€’å½’ç§»åŠ¨å­å­™èŠ‚ç‚¹
                });
            }
            if (node._children) {
                node._children.forEach(child => {
                    child.x += moveDistance;
                    moveDescendants(child, moveDistance); // é€’å½’ç§»åŠ¨æŠ˜å çš„å­å­™èŠ‚ç‚¹
                });
            }
        }

        // è°ƒæ•´çˆ¶èŠ‚ç‚¹ä½ç½®ä»¥ä¿æŒä¸å­èŠ‚ç‚¹çš„å¹³è¡¡
        function adjustParentPositions(subtrees) {
            subtrees.forEach(subtree => {
                if (subtree.parent && subtree.nodes.length > 0) {
                    // è®¡ç®—å­èŠ‚ç‚¹çš„ä¸­å¿ƒä½ç½®
                    const childrenCenterX = subtree.nodes.reduce((sum, node) => sum + node.x, 0) / subtree.nodes.length;

                    // å¦‚æœçˆ¶èŠ‚ç‚¹ä½ç½®ä¸å­èŠ‚ç‚¹ä¸­å¿ƒç›¸å·®å¤ªå¤§ï¼Œè¿›è¡Œå¾®è°ƒ
                    const maxAdjustment = 30; // æœ€å¤§è°ƒæ•´è·ç¦»
                    const desiredAdjustment = childrenCenterX - subtree.parent.x;
                    const actualAdjustment = Math.max(-maxAdjustment, Math.min(maxAdjustment, desiredAdjustment));

                    if (Math.abs(actualAdjustment) > 5) { // åªæœ‰å½“è°ƒæ•´è·ç¦»è¶³å¤Ÿå¤§æ—¶æ‰è¿›è¡Œè°ƒæ•´
                        subtree.parent.x += actualAdjustment * 0.3; // ä½¿ç”¨è¾ƒå°çš„è°ƒæ•´ç³»æ•°ä»¥é¿å…è¿‡åº¦è°ƒæ•´
                    }
                }
            });
        }

        // æ£€æµ‹å¹¶è§£å†³å‚ç›´é‡å ï¼ˆæ°´å¹³å¸ƒå±€ï¼‰
        function resolveVerticalOverlaps(nodes) {
            const nodesByDepth = {};
            nodes.forEach(d => {
                if (!nodesByDepth[d.depth]) nodesByDepth[d.depth] = [];
                nodesByDepth[d.depth].push(d);
            });

            Object.values(nodesByDepth).forEach(levelNodes => {
                if (levelNodes.length <= 1) return;

                // æŒ‰å‚ç›´ä½ç½®æ’åº
                levelNodes.sort((a, b) => a.x - b.x);

                // è®¡ç®—åŸå§‹ä¸­å¿ƒä½ç½®
                const originalCenter = levelNodes.reduce((sum, node) => sum + node.x, 0) / levelNodes.length;

                // æ£€æµ‹é‡å å¹¶è°ƒæ•´ä½ç½®
                for (let i = 1; i < levelNodes.length; i++) {
                    const current = levelNodes[i];
                    const previous = levelNodes[i - 1];
                    const minDistance = 60; // æœ€å°å‚ç›´è·ç¦»

                    if (current.x - previous.x < minDistance) {
                        current.x = previous.x + minDistance;
                    }
                }

                // é‡æ–°è®¡ç®—ä¸­å¿ƒä½ç½®å¹¶ä¿æŒç›¸å¯¹äºåŸå§‹ä¸­å¿ƒçš„ä½ç½®
                const newCenter = levelNodes.reduce((sum, node) => sum + node.x, 0) / levelNodes.length;
                const centerOffset = originalCenter - newCenter;
                levelNodes.forEach(node => {
                    node.x += centerOffset;
                });
            });
        }

        // æ£€æµ‹å¹¶è§£å†³æ°´å¹³é‡å ï¼ˆå‚ç›´å¸ƒå±€ï¼‰
        function resolveHorizontalOverlaps(nodes) {
            const nodesByDepth = {};
            nodes.forEach(d => {
                if (!nodesByDepth[d.depth]) nodesByDepth[d.depth] = [];
                nodesByDepth[d.depth].push(d);
            });

            Object.values(nodesByDepth).forEach(levelNodes => {
                if (levelNodes.length <= 1) return;

                // æŒ‰æ°´å¹³ä½ç½®æ’åº
                levelNodes.sort((a, b) => a.y - b.y);

                // è®¡ç®—åŸå§‹ä¸­å¿ƒä½ç½®
                const originalCenter = levelNodes.reduce((sum, node) => sum + node.y, 0) / levelNodes.length;

                // æ£€æµ‹é‡å å¹¶è°ƒæ•´ä½ç½®
                for (let i = 1; i < levelNodes.length; i++) {
                    const current = levelNodes[i];
                    const previous = levelNodes[i - 1];
                    const currentWidth = getTextWidth(current.data.name, current.data.style?.fontSize || 14);
                    const minDistance = Math.max(currentWidth + 40, 100);

                    if (current.y - previous.y < minDistance) {
                        current.y = previous.y + minDistance;
                    }
                }

                // é‡æ–°è®¡ç®—ä¸­å¿ƒä½ç½®å¹¶ä¿æŒç›¸å¯¹äºåŸå§‹ä¸­å¿ƒçš„ä½ç½®
                const newCenter = levelNodes.reduce((sum, node) => sum + node.y, 0) / levelNodes.length;
                const centerOffset = originalCenter - newCenter;
                levelNodes.forEach(node => {
                    node.y += centerOffset;
                });
            });
        }

        // æ£€æµ‹å¹¶è§£å†³å¾„å‘é‡å ï¼ˆå¾„å‘å¸ƒå±€ï¼‰
        function resolveRadialOverlaps(nodes) {
            const nodesByDepth = {};
            nodes.forEach(d => {
                if (!nodesByDepth[d.depth]) nodesByDepth[d.depth] = [];
                nodesByDepth[d.depth].push(d);
            });

            Object.values(nodesByDepth).forEach(levelNodes => {
                if (levelNodes.length <= 1) return;

                // æŒ‰è§’åº¦æ’åº
                levelNodes.sort((a, b) => {
                    const angleA = Math.atan2(a.y, a.x);
                    const angleB = Math.atan2(b.y, b.x);
                    return angleA - angleB;
                });

                // ç¡®ä¿è§’åº¦é—´è·è¶³å¤Ÿ
                const minAngleDistance = Math.max(0.3, 2 * Math.PI / (levelNodes.length * 2));

                for (let i = 1; i < levelNodes.length; i++) {
                    const current = levelNodes[i];
                    const previous = levelNodes[i - 1];

                    const currentAngle = Math.atan2(current.y, current.x);
                    const previousAngle = Math.atan2(previous.y, previous.x);

                    if (currentAngle - previousAngle < minAngleDistance) {
                        const newAngle = previousAngle + minAngleDistance;
                        const radius = Math.sqrt(current.x * current.x + current.y * current.y);
                        current.x = radius * Math.cos(newAngle);
                        current.y = radius * Math.sin(newAngle);
                    }
                }
            });
        }

        // å‚ç›´é‡æ–°åˆ†å¸ƒ - ç”¨äºæ°´å¹³å¸ƒå±€
        function redistributeVertically(nodes) {
            // æŒ‰æ·±åº¦åˆ†ç»„
            const nodesByDepth = {};
            nodes.forEach(d => {
                if (!nodesByDepth[d.depth]) {
                    nodesByDepth[d.depth] = [];
                }
                nodesByDepth[d.depth].push(d);
            });

            // å¯¹æ¯ä¸ªæ·±åº¦çº§åˆ«é‡æ–°åˆ†å¸ƒèŠ‚ç‚¹
            Object.keys(nodesByDepth).forEach(depth => {
                const levelNodes = nodesByDepth[depth];
                if (levelNodes.length <= 1) return;

                // æŒ‰å½“å‰å‚ç›´ä½ç½®æ’åº
                levelNodes.sort((a, b) => a.x - b.x);

                // è®¡ç®—æ€»çš„å¯ç”¨å‚ç›´ç©ºé—´
                const availableHeight = height - 200;
                const nodeSpacing = Math.max(80, availableHeight / (levelNodes.length + 1));

                // é‡æ–°å‡åŒ€åˆ†å¸ƒèŠ‚ç‚¹
                levelNodes.forEach((node, index) => {
                    node.x = (index + 1) * nodeSpacing - availableHeight / 2;
                });
            });
        }

        // æ°´å¹³é‡æ–°åˆ†å¸ƒ - ç”¨äºå‚ç›´å¸ƒå±€
        function redistributeHorizontally(nodes) {
            // æŒ‰æ·±åº¦åˆ†ç»„
            const nodesByDepth = {};
            nodes.forEach(d => {
                if (!nodesByDepth[d.depth]) {
                    nodesByDepth[d.depth] = [];
                }
                nodesByDepth[d.depth].push(d);
            });

            // å¯¹æ¯ä¸ªæ·±åº¦çº§åˆ«é‡æ–°åˆ†å¸ƒèŠ‚ç‚¹
            Object.keys(nodesByDepth).forEach(depth => {
                const levelNodes = nodesByDepth[depth];
                if (levelNodes.length <= 1) return;

                // æŒ‰å½“å‰æ°´å¹³ä½ç½®æ’åº
                levelNodes.sort((a, b) => a.y - b.y);

                // è®¡ç®—æ€»çš„å¯ç”¨æ°´å¹³ç©ºé—´
                const availableWidth = width - 400;
                const nodeSpacing = Math.max(120, availableWidth / (levelNodes.length + 1));

                // é‡æ–°å‡åŒ€åˆ†å¸ƒèŠ‚ç‚¹
                levelNodes.forEach((node, index) => {
                    node.y = (index + 1) * nodeSpacing - availableWidth / 2;
                });
            });
        }

        // æ›´æ–°æ€ç»´å¯¼å›¾ - æ™ºèƒ½å¸ƒå±€ç³»ç»Ÿ
        function update(source) {
            // åŠ¨æ€è®¡ç®—èŠ‚ç‚¹é—´è·ï¼Œé˜²æ­¢é‡å 
            const nodeSpacing = calculateDynamicSpacing();

            // ä½¿ç”¨æ™ºèƒ½åˆ†ç¦»å‡½æ•°
            if (currentLayout === 'horizontal') {
                tree = d3.tree()
                    .size([height - 100, width - 200])
                    .separation((a, b) => {
                        // æ”¹è¿›çš„åˆ†ç¦»ç®—æ³•ï¼šæ›´å‡åŒ€çš„åˆ†å¸ƒ
                        if (a.parent === b.parent) {
                            // åŒçº§èŠ‚ç‚¹ï¼šåŸºäºæ–‡æœ¬é•¿åº¦åŠ¨æ€è°ƒæ•´
                            const aTextWidth = getTextWidth(a.data.name, a.data.style?.fontSize || 14);
                            const bTextWidth = getTextWidth(b.data.name, b.data.style?.fontSize || 14);
                            const maxTextWidth = Math.max(aTextWidth, bTextWidth);
                            return Math.max(1.2, maxTextWidth / 80); // ç¡®ä¿æœ€å°é—´è·
                        } else {
                            // ä¸åŒçˆ¶èŠ‚ç‚¹ï¼šæ›´å¤§é—´è·
                            return 2.0;
                        }
                    });
            } else if (currentLayout === 'vertical') {
                tree = d3.tree()
                    .size([width - 200, height - 100])
                    .separation((a, b) => {
                        const baseSpacing = a.parent === b.parent ? 1.5 : 2.5;
                        const textFactor = Math.max(
                            getTextWidth(a.data.name, a.data.style?.fontSize || 14),
                            getTextWidth(b.data.name, b.data.style?.fontSize || 14)
                        ) / 100;
                        return baseSpacing + textFactor;
                    });
            } else if (currentLayout === 'radial') {
                tree = d3.tree()
                    .size([2 * Math.PI, Math.min(width, height) / 2 - 100])
                    .separation((a, b) => {
                        const baseSpacing = a.parent === b.parent ? 1.2 : 2.0;
                        const depthFactor = Math.max(a.depth, b.depth) * 0.3;
                        return baseSpacing + depthFactor;
                    });
            }

            const treeData = tree(root);
            const nodes = treeData.descendants();
            const links = treeData.descendants().slice(1);

            // æ€§èƒ½æ£€æµ‹å’Œä¼˜åŒ–
            checkPerformanceMode(nodes.length);

            // æ™ºèƒ½å¸ƒå±€ä½ç½®è°ƒæ•´ï¼Œé˜²æ­¢é‡å 
            if (currentLayout === 'horizontal') {
                nodes.forEach(d => {
                    d.y = d.depth * nodeSpacing.horizontal;
                });
                // åº”ç”¨å¹³è¡¡å¸ƒå±€ç®—æ³•
                balanceHorizontalLayout(nodes);
                // æ£€æµ‹å¹¶è§£å†³å‚ç›´é‡å 
                resolveVerticalOverlaps(nodes);
            } else if (currentLayout === 'vertical') {
                nodes.forEach(d => {
                    const temp = d.x;
                    d.x = d.depth * nodeSpacing.horizontal;
                    d.y = temp;
                });
                // æ£€æµ‹å¹¶è§£å†³æ°´å¹³é‡å 
                resolveHorizontalOverlaps(nodes);
            } else if (currentLayout === 'radial') {
                nodes.forEach(d => {
                    const angle = d.x;
                    const radius = Math.max(d.y, d.depth * 80); // ç¡®ä¿æœ€å°åŠå¾„
                    d.x = radius * Math.cos(angle - Math.PI / 2);
                    d.y = radius * Math.sin(angle - Math.PI / 2);
                });
                // æ£€æµ‹å¹¶è§£å†³å¾„å‘é‡å 
                resolveRadialOverlaps(nodes);
            }
            
            // æ›´æ–°èŠ‚ç‚¹
            const node = g.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));
            
            // è¿›å…¥æ–°èŠ‚ç‚¹
            const nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${source.y0},${source.x0})`)
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // æ·»åŠ èŠ‚ç‚¹ç»ˆç‚¹æ ‡è®°ï¼ˆå°åœ†ç‚¹ï¼‰- æ”¾åœ¨èŠ‚ç‚¹èµ·ç‚¹
            nodeEnter.append('circle')
                .attr('class', 'node-point')
                .attr('r', 3)
                .attr('cx', 8)  // å›ºå®šåœ¨èŠ‚ç‚¹èµ·ç‚¹ä½ç½®
                .attr('cy', 0)
                .style('fill', '#4fc3f7')
                .style('stroke', '#ffffff')
                .style('stroke-width', 1);

            // æ·»åŠ é€æ˜çš„ç‚¹å‡»åŒºåŸŸï¼ˆæ‰©å¤§ç‚¹å‡»èŒƒå›´ï¼‰
            nodeEnter.append('rect')
                .attr('class', 'click-area')
                .attr('width', function(d) {
                    const fontSize = d.data.style ? d.data.style.fontSize : 14;
                    const textWidth = getTextWidth(d.data.name, fontSize);
                    return Math.max(textWidth + 50, 120); // å¢åŠ å®½åº¦ä»¥é€‚åº”æ–°çš„æ–‡æœ¬ä½ç½®
                })
                .attr('height', 30) // å¢åŠ é«˜åº¦ä»¥é˜²æ­¢é‡å 
                .attr('x', 5)  // ä»å°åœ†ç‚¹å·¦ä¾§å¼€å§‹ï¼Œè¦†ç›–åœ†ç‚¹å’Œæ–‡å­—
                .attr('y', -15) // è°ƒæ•´å‚ç›´ä½ç½®
                .style('fill', 'transparent')
                .style('cursor', 'pointer')
                .on('click', click)
                .on('contextmenu', rightClick)
                .on('dblclick', doubleClick);

            // æ·»åŠ æ–‡æœ¬ï¼ˆä»å°åœ†ç‚¹å³ä¾§å¼€å§‹ï¼Œå‘å³ç§»åŠ¨æ›´å¤šï¼‰
            const textElements = nodeEnter.append('text')
                .attr('dy', '.35em')
                .attr('text-anchor', 'start')  // æ–‡å­—å·¦å¯¹é½ï¼Œä»åœ†ç‚¹å³ä¾§å‘å³
                .attr('x', 20)  // å¢åŠ è·ç¦»ï¼Œä»å°åœ†ç‚¹æ›´å³ä¾§å¼€å§‹æ˜¾ç¤ºæ–‡å­—
                .text(d => d.data.name)
                .style('fill', d => d.data.style ? d.data.style.textColor : '#ffffff')
                .style('font-size', d => d.data.style ? d.data.style.fontSize + 'px' : '14px')
                .style('font-weight', d => d.data.style ? d.data.style.fontWeight : 'normal')
                .style('font-style', d => d.data.style && d.data.style.fontItalic ? 'italic' : 'normal')
                .style('fill-opacity', 1e-6);

            // æ·»åŠ åº•éƒ¨æ¨ªçº¿ï¼ˆä»å°åœ†ç‚¹å³ä¾§å¼€å§‹ï¼Œè¦†ç›–æ–‡å­—ï¼‰
            nodeEnter.insert('line', 'text')
                .attr('class', 'node-underline')
                .attr('x1', 20)  // ä»æ–°çš„æ–‡å­—èµ·ç‚¹å¼€å§‹
                .attr('x2', function(d) {
                    const fontSize = d.data.style ? d.data.style.fontSize : 14;
                    const textWidth = getTextWidth(d.data.name, fontSize);
                    // ä½¿ç”¨å®é™…æ–‡å­—å®½åº¦ï¼Œç¡®ä¿ä¸‹åˆ’çº¿ç²¾ç¡®è¦†ç›–æ–‡å­—
                    return 20 + Math.max(textWidth, 50);  // ä»æ–‡å­—èµ·ç‚¹å‘å³å»¶ä¼¸
                })
                .attr('y1', 12) // ç¨å¾®ä¸‹ç§»é¿å…ä¸æ–‡å­—é‡å 
                .attr('y2', 12)
                .style('stroke', d => d.data.style ? d.data.style.underlineColor : (d._children ? '#4fc3f7' : '#81c784'))
                .style('stroke-width', 2)
                .style('opacity', 1e-6);
            
            // æ›´æ–°ç°æœ‰èŠ‚ç‚¹
            const nodeUpdate = nodeEnter.merge(node);

            // æ™ºèƒ½åŠ¨ç”»ç³»ç»Ÿï¼šæ ¹æ®èŠ‚ç‚¹æ•°é‡å’Œè·ç¦»è°ƒæ•´åŠ¨ç”»
            const animationDuration = calculateAnimationDuration(nodes.length);
            const animationEase = nodes.length > 50 ? d3.easeCubicOut : d3.easeBackOut.overshoot(1.2);

            nodeUpdate.transition()
                .duration(animationDuration)
                .ease(animationEase)
                .delay((d, i) => i * 20) // æ·»åŠ äº¤é”™åŠ¨ç”»æ•ˆæœ
                .attr('transform', d => `translate(${d.y},${d.x})`);
            
            nodeUpdate.select('.node-underline')
                .attr('x1', 20)  // ä»æ–°çš„æ–‡å­—èµ·ç‚¹å¼€å§‹
                .attr('x2', function(d) {
                    const fontSize = d.data.style ? d.data.style.fontSize : 14;
                    const textWidth = getTextWidth(d.data.name, fontSize);
                    return 20 + Math.max(textWidth, 50);  // ä½¿ç”¨å®é™…æ–‡å­—å®½åº¦
                })
                .style('stroke', d => d.data.style ? d.data.style.underlineColor : (d._children ? '#4fc3f7' : '#81c784'))
                .style('opacity', 1)
                .style('cursor', 'pointer');

            // æ›´æ–°ç‚¹å‡»åŒºåŸŸ
            nodeUpdate.select('.click-area')
                .attr('width', function(d) {
                    const fontSize = d.data.style ? d.data.style.fontSize : 14;
                    const textWidth = getTextWidth(d.data.name, fontSize);
                    return Math.max(textWidth + 50, 120); // å¢åŠ å®½åº¦ä»¥é€‚åº”æ–°çš„æ–‡æœ¬ä½ç½®
                });

            // æ›´æ–°èŠ‚ç‚¹ç»ˆç‚¹åœ†ç‚¹ä½ç½®ï¼ˆä¿æŒåœ¨å›ºå®šä½ç½®ï¼‰
            nodeUpdate.select('.node-point')
                .attr('cx', 8);  // ä¿æŒåœ¨å›ºå®šä½ç½®

            // åº”ç”¨æ€§èƒ½ä¼˜åŒ–
            optimizeNodeRendering(nodeUpdate);

            nodeUpdate.select('text')
                .style('fill', d => d.data.style ? d.data.style.textColor : '#ffffff')
                .style('font-size', d => d.data.style ? d.data.style.fontSize + 'px' : '14px')
                .style('font-weight', d => d.data.style ? d.data.style.fontWeight : 'normal')
                .style('font-style', d => d.data.style && d.data.style.fontItalic ? 'italic' : 'normal')
                .style('fill-opacity', 1);
            
            // ç§»é™¤é€€å‡ºçš„èŠ‚ç‚¹
            const nodeExit = node.exit().transition()
                .duration(750)
                .attr('transform', d => `translate(${source.y},${source.x})`)
                .remove();
            
            nodeExit.select('.node-underline')
                .style('opacity', 1e-6);
            
            nodeExit.select('text')
                .style('fill-opacity', 1e-6);
            
            // æ›´æ–°é“¾æ¥
            const link = g.selectAll('path.link')
                .data(links, d => d.id);
            
            const linkEnter = link.enter().insert('path', 'g')
                .attr('class', 'link')
                .attr('d', d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal(o, o);
                });
            
            const linkUpdate = linkEnter.merge(link);

            // é“¾æ¥åŠ¨ç”»ä¸èŠ‚ç‚¹åŠ¨ç”»åŒæ­¥
            linkUpdate.transition()
                .duration(animationDuration)
                .ease(animationEase)
                .delay((d, i) => i * 15) // ç¨å¾®å¿«äºèŠ‚ç‚¹åŠ¨ç”»
                .attr('d', d => diagonal(d, d.parent))
                .style('stroke-opacity', 1);

            const linkExit = link.exit().transition()
                .duration(animationDuration / 2) // é€€å‡ºåŠ¨ç”»æ›´å¿«
                .ease(d3.easeCubicIn)
                .attr('d', d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal(o, o);
                })
                .style('stroke-opacity', 0)
                .remove();
            
            // å­˜å‚¨æ—§ä½ç½®
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
        
        // è¿çº¿ç”Ÿæˆå™¨ - ä¼ ç»Ÿæ€ç»´å¯¼å›¾æ›²çº¿æ ·å¼
        function diagonal(s, d) {
            if (currentLayout === 'horizontal') {
                // æ°´å¹³å¸ƒå±€ï¼šå¹³æ»‘çš„è´å¡å°”æ›²çº¿
                const startX = s.x;
                const startY = s.y;
                const endX = d.x;
                const endY = d.y;

                return `M ${startY} ${startX}
                        C ${(startY + endY) / 2} ${startX},
                          ${(startY + endY) / 2} ${endX},
                          ${endY} ${endX}`;
            } else if (currentLayout === 'vertical') {
                // å‚ç›´å¸ƒå±€ï¼šå¹³æ»‘çš„è´å¡å°”æ›²çº¿
                const startX = s.x;
                const startY = s.y;
                const endX = d.x;
                const endY = d.y;

                return `M ${startX} ${startY}
                        C ${startX} ${(startY + endY) / 2},
                          ${endX} ${(startY + endY) / 2},
                          ${endX} ${endY}`;
            } else {
                // è¾å°„çŠ¶å¸ƒå±€ï¼šç›´çº¿è¿æ¥
                return `M ${s.x} ${s.y} L ${d.x} ${d.y}`;
            }
        }
        
        // æ™ºèƒ½èŠ‚ç‚¹ç‚¹å‡»äº‹ä»¶
        function click(event, d) {
            event.stopPropagation();

            // é˜²æ­¢å¿«é€Ÿè¿ç»­ç‚¹å‡»
            if (d._animating) return;
            d._animating = true;

            setTimeout(() => {
                d._animating = false;
            }, 800);

            if (d.children) {
                // æ”¶èµ·èŠ‚ç‚¹
                d._children = d.children;
                d.children = null;
                updateStatus(`å·²æ”¶èµ·èŠ‚ç‚¹: ${d.data.name}`, 'info');
            } else if (d._children) {
                // å±•å¼€èŠ‚ç‚¹
                d.children = d._children;
                d._children = null;
                updateStatus(`å·²å±•å¼€èŠ‚ç‚¹: ${d.data.name}ï¼ŒåŒ…å« ${d.children.length} ä¸ªå­èŠ‚ç‚¹`, 'success');
            }

            // æ™ºèƒ½æ›´æ–°ï¼šå¦‚æœå±•å¼€çš„èŠ‚ç‚¹å¾ˆå¤šï¼Œå…ˆé‡æ–°è®¡ç®—å¸ƒå±€
            const visibleNodes = root.descendants().filter(node => !node._children || node.children);
            if (visibleNodes.length > 50) {
                updateStatus('èŠ‚ç‚¹è¾ƒå¤šï¼Œæ­£åœ¨ä¼˜åŒ–å¸ƒå±€...', 'info');
                setTimeout(() => update(d), 100);
            } else {
                update(d);
            }
        }

        // æ‹–æ‹½äº‹ä»¶
        function dragstarted(event, d) {
            if (!event.active) {
                // åœæ­¢ä»»ä½•æ­£åœ¨è¿›è¡Œçš„è¿‡æ¸¡åŠ¨ç”»
                d3.select(this).interrupt();
            }
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            // æ›´æ–°èŠ‚ç‚¹çš„å›ºå®šä½ç½®
            d.fx = event.x;
            d.fy = event.y;

            // ç«‹å³æ›´æ–°èŠ‚ç‚¹ä½ç½®
            d.x = event.x;
            d.y = event.y;

            // æ›´æ–°å½“å‰èŠ‚ç‚¹çš„å˜æ¢
            d3.select(this).attr('transform', `translate(${d.y},${d.x})`);

            // æ›´æ–°è¿æ¥åˆ°æ­¤èŠ‚ç‚¹çš„é“¾æ¥
            g.selectAll('path.link')
                .filter(link => link.source === d || link.target === d)
                .attr('d', link => diagonal(link.source, link.target));
        }

        function dragended(event, d) {
            if (!event.active) {
                // æ‹–æ‹½ç»“æŸåå¯ä»¥æ·»åŠ ä¸€äº›é€»è¾‘
            }
            // ä¿æŒèŠ‚ç‚¹åœ¨æ‹–æ‹½åçš„ä½ç½®
            // d.fx = null;
            // d.fy = null;
        }
        
        // å³é”®ç‚¹å‡»äº‹ä»¶
        function rightClick(event, d) {
            event.preventDefault();
            currentNode = d;
            
            const contextMenu = document.getElementById('context-menu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = event.pageX + 'px';
            contextMenu.style.top = event.pageY + 'px';
        }
        
        // åŒå‡»ç¼–è¾‘
        function doubleClick(event, d) {
            event.stopPropagation();
            currentNode = d;
            showNodeEditor(d.data.name);
        }
        
        // éšè—å³é”®èœå•
        document.addEventListener('click', function() {
            document.getElementById('context-menu').style.display = 'none';
        });
        
        // æ˜¾ç¤ºèŠ‚ç‚¹ç¼–è¾‘å™¨
        function showNodeEditor(currentName = '') {
            const editor = document.getElementById('node-editor');
            const input = document.getElementById('node-name-input');
            input.value = currentName;
            editor.style.display = 'block';
            input.focus();
        }
        
        // ä¿å­˜èŠ‚ç‚¹ç¼–è¾‘
        function saveNodeEdit() {
            const newName = document.getElementById('node-name-input').value.trim();
            if (newName && currentNode) {
                currentNode.data.name = newName;
                update(currentNode);
                updateStatus('èŠ‚ç‚¹å·²æ›´æ–°', 'success');
            }
            cancelNodeEdit();
        }
        
        // å–æ¶ˆèŠ‚ç‚¹ç¼–è¾‘
        function cancelNodeEdit() {
            document.getElementById('node-editor').style.display = 'none';
            currentNode = null;
        }
        
        // å³é”®èœå•åŠŸèƒ½
        function editNode() {
            if (currentNode) {
                showNodeEditor(currentNode.data.name);
            }
        }

        // ç¼–è¾‘èŠ‚ç‚¹æ ·å¼
        function editNodeStyle() {
            if (currentNode) {
                showNodeStyleEditor();
            }
        }

        // æ˜¾ç¤ºèŠ‚ç‚¹æ ·å¼ç¼–è¾‘å™¨
        function showNodeStyleEditor() {
            if (!currentNode) return;

            const editor = document.getElementById('node-style-editor');
            // ç¡®ä¿èŠ‚ç‚¹æœ‰æ ·å¼å¯¹è±¡
            if (!currentNode.data.style) {
                currentNode.data.style = {
                    textColor: '#ffffff',
                    fontSize: 14,
                    fontWeight: 'normal',
                    fontItalic: false,
                    underlineColor: '#81c784'
                };
            }
            const style = currentNode.data.style;

            // è®¾ç½®å½“å‰æ ·å¼å€¼
            document.getElementById('node-text-color').value = style.textColor;
            document.getElementById('node-font-size').value = style.fontSize;
            document.getElementById('node-font-size-value').textContent = style.fontSize + 'px';
            document.getElementById('node-font-weight').value = style.fontWeight;
            document.getElementById('node-font-italic').checked = style.fontItalic;
            document.getElementById('node-underline-color').value = style.underlineColor;

            editor.style.display = 'block';
        }

        // ä¿å­˜èŠ‚ç‚¹æ ·å¼
        function saveNodeStyle() {
            if (!currentNode) return;

            const style = {
                textColor: document.getElementById('node-text-color').value,
                fontSize: parseInt(document.getElementById('node-font-size').value),
                fontWeight: document.getElementById('node-font-weight').value,
                fontItalic: document.getElementById('node-font-italic').checked,
                underlineColor: document.getElementById('node-underline-color').value
            };

            // ç¡®ä¿èŠ‚ç‚¹æœ‰æ ·å¼å¯¹è±¡
            if (!currentNode.data.style) {
                currentNode.data.style = {};
            }

            // æ›´æ–°æ ·å¼
            Object.assign(currentNode.data.style, style);

            // é‡æ–°æ¸²æŸ“èŠ‚ç‚¹
            update(currentNode);
            updateStatus('èŠ‚ç‚¹æ ·å¼å·²æ›´æ–°', 'success');

            cancelNodeStyleEdit();
        }

        // å–æ¶ˆèŠ‚ç‚¹æ ·å¼ç¼–è¾‘
        function cancelNodeStyleEdit() {
            document.getElementById('node-style-editor').style.display = 'none';
        }

        // å­—ä½“å¤§å°æ»‘å—äº‹ä»¶
        document.addEventListener('DOMContentLoaded', function() {
            const fontSizeSlider = document.getElementById('node-font-size');
            if (fontSizeSlider) {
                fontSizeSlider.addEventListener('input', function() {
                    document.getElementById('node-font-size-value').textContent = this.value + 'px';
                });
            }
        });
        
        function addChildNode() {
            if (currentNode) {
                const newNode = {
                    name: 'æ–°èŠ‚ç‚¹',
                    children: []
                };
                
                if (!currentNode.data.children) {
                    currentNode.data.children = [];
                }
                currentNode.data.children.push(newNode);
                
                // é‡æ–°æ¸²æŸ“
                renderMindmap(mindmapData);
                updateStatus('å·²æ·»åŠ å­èŠ‚ç‚¹', 'success');
            }
        }
        
        function deleteNode() {
            if (currentNode && currentNode.parent) {
                const parent = currentNode.parent;
                const index = parent.data.children.indexOf(currentNode.data);
                if (index > -1) {
                    parent.data.children.splice(index, 1);
                    renderMindmap(mindmapData);
                    updateStatus('èŠ‚ç‚¹å·²åˆ é™¤', 'success');
                }
            }
        }
        
        async function generateAIContent() {
            if (currentNode) {
                try {
                    updateStatus('æ­£åœ¨ç”ŸæˆAIå†…å®¹...', 'info');
                    
                    const response = await fetch('/api/mindmap/generate-section/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            section_title: currentNode.data.name,
                            notes_content: 'placeholder' // è¿™é‡Œéœ€è¦ä¼ å…¥å®Œæ•´çš„ç¬”è®°å†…å®¹
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        // æ›´æ–°èŠ‚ç‚¹å†…å®¹
                        currentNode.data.children = data.refined_mindmap.children || [];
                        renderMindmap(mindmapData);
                        updateStatus('AIå†…å®¹ç”ŸæˆæˆåŠŸ', 'success');
                    } else {
                        throw new Error(data.error);
                    }
                    
                } catch (error) {
                    updateStatus(`AIç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
                }
            }
        }
        
        // å·¥å…·å‡½æ•°
        function resetView() {
            svg.transition().duration(750).call(
                d3.zoom().transform,
                d3.zoomIdentity
            );
        }

        // æ™ºèƒ½é‡æ–°æ•´ç†å¸ƒå±€ - æ¸…ç†æ··ä¹±çš„èŠ‚ç‚¹æ’åˆ—
        function resetLayout() {
            if (!root) {
                updateStatus('æ²¡æœ‰å¯é‡ç½®çš„æ€ç»´å¯¼å›¾', 'error');
                return;
            }

            updateStatus('æ­£åœ¨é‡æ–°æ•´ç†å¸ƒå±€...', 'info');

            // æ¸…é™¤æ‰€æœ‰èŠ‚ç‚¹çš„å›ºå®šä½ç½®å’ŒåŠ¨ç”»çŠ¶æ€
            root.descendants().forEach(d => {
                delete d.fx;
                delete d.fy;
                delete d.x0;
                delete d.y0;
                delete d._animating;
            });

            // é‡æ–°è®¡ç®—æœ€ä¼˜å¸ƒå±€
            update(root);

            // é‡ç½®è§†å›¾åˆ°åˆé€‚çš„ä½ç½®
            setTimeout(() => {
                resetView();
                updateStatus('å¸ƒå±€å·²é‡æ–°æ•´ç†ï¼Œè§†å›¾å·²å±…ä¸­', 'success');
            }, 500);
        }
        
        // æ™ºèƒ½æ¸è¿›å¼å±•å¼€å…¨éƒ¨
        function expandAll() {
            if (!root) return;

            updateStatus('æ­£åœ¨å±•å¼€å…¨éƒ¨èŠ‚ç‚¹...', 'info');

            const allNodes = root.descendants();
            const collapsedNodes = allNodes.filter(d => d._children);

            if (collapsedNodes.length === 0) {
                updateStatus('æ‰€æœ‰èŠ‚ç‚¹å·²å±•å¼€', 'info');
                return;
            }

            // æ¸è¿›å¼å±•å¼€ï¼šæŒ‰æ·±åº¦é€å±‚å±•å¼€
            const nodesByDepth = {};
            collapsedNodes.forEach(d => {
                if (!nodesByDepth[d.depth]) nodesByDepth[d.depth] = [];
                nodesByDepth[d.depth].push(d);
            });

            const depths = Object.keys(nodesByDepth).sort((a, b) => a - b);
            let currentDepthIndex = 0;

            function expandNextDepth() {
                if (currentDepthIndex >= depths.length) {
                    updateStatus(`å±•å¼€å®Œæˆï¼Œå…±å±•å¼€ ${collapsedNodes.length} ä¸ªèŠ‚ç‚¹`, 'success');
                    return;
                }

                const currentDepth = depths[currentDepthIndex];
                const nodesAtDepth = nodesByDepth[currentDepth];

                nodesAtDepth.forEach(d => {
                    d.children = d._children;
                    d._children = null;
                });

                update(root);
                currentDepthIndex++;

                // å»¶è¿Ÿå±•å¼€ä¸‹ä¸€å±‚ï¼Œé¿å…åŠ¨ç”»å†²çª
                setTimeout(expandNextDepth, 400);
            }

            expandNextDepth();
        }

        // æ™ºèƒ½æ”¶èµ·å…¨éƒ¨
        function collapseAll() {
            if (!root) return;

            updateStatus('æ­£åœ¨æ”¶èµ·å…¨éƒ¨èŠ‚ç‚¹...', 'info');

            const allNodes = root.descendants();
            const expandedNodes = allNodes.filter(d => d.children && d.depth > 0);

            if (expandedNodes.length === 0) {
                updateStatus('æ‰€æœ‰èŠ‚ç‚¹å·²æ”¶èµ·', 'info');
                return;
            }

            // å¿«é€Ÿæ”¶èµ·æ‰€æœ‰èŠ‚ç‚¹
            expandedNodes.forEach(d => {
                d._children = d.children;
                d.children = null;
            });

            update(root);
            updateStatus(`æ”¶èµ·å®Œæˆï¼Œå…±æ”¶èµ· ${expandedNodes.length} ä¸ªèŠ‚ç‚¹`, 'success');
        }
        
        function exportMindmap() {
            if (mindmapData) {
                const dataStr = JSON.stringify(mindmapData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'mindmap.json';
                link.click();
                URL.revokeObjectURL(url);
                updateStatus('æ€ç»´å¯¼å›¾å·²å¯¼å‡º', 'success');
            }
        }



        // æœç´¢èŠ‚ç‚¹åŠŸèƒ½
        function searchNodes(searchTerm) {
            if (!searchTerm.trim()) {
                clearSearch();
                return;
            }

            // é‡ç½®æ‰€æœ‰èŠ‚ç‚¹æ ·å¼
            svg.selectAll('.node text').style('fill', d => d.data.style ? d.data.style.textColor : '#ffffff');
            svg.selectAll('.node-underline').style('stroke', d => d.data.style ? d.data.style.underlineColor : (d._children ? '#4fc3f7' : '#81c784'));

            // é«˜äº®åŒ¹é…çš„èŠ‚ç‚¹
            svg.selectAll('.node')
                .filter(d => d.data.name.toLowerCase().includes(searchTerm.toLowerCase()))
                .select('text')
                .style('fill', '#ffeb3b');  // é»„è‰²é«˜äº®

            svg.selectAll('.node')
                .filter(d => d.data.name.toLowerCase().includes(searchTerm.toLowerCase()))
                .select('.node-underline')
                .style('stroke', '#ffeb3b');  // é»„è‰²é«˜äº®
        }

        // æ¸…é™¤æœç´¢é«˜äº®
        function clearSearch() {
            document.getElementById('search-input').value = '';
            svg.selectAll('.node text').style('fill', d => d.data.style ? d.data.style.textColor : '#ffffff');
            svg.selectAll('.node-underline').style('stroke', d => d.data.style ? d.data.style.underlineColor : (d._children ? '#4fc3f7' : '#81c784'));
        }

        // å¯¼å‡ºä¸ºPNGå›¾ç‰‡
        function exportAsPNG() {
            if (!svg) {
                updateStatus('è¯·å…ˆåŠ è½½æ€ç»´å¯¼å›¾', 'error');
                return;
            }

            try {
                // è·å–SVGå…ƒç´ 
                const svgElement = document.getElementById('mindmap-svg');
                const svgData = new XMLSerializer().serializeToString(svgElement);

                // åˆ›å»ºcanvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                // è®¾ç½®canvaså¤§å°
                canvas.width = svgElement.clientWidth || 800;
                canvas.height = svgElement.clientHeight || 600;

                // è®¾ç½®ç™½è‰²èƒŒæ™¯
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                img.onload = function() {
                    ctx.drawImage(img, 0, 0);

                    // ä¸‹è½½å›¾ç‰‡
                    const link = document.createElement('a');
                    link.download = 'mindmap.png';
                    link.href = canvas.toDataURL();
                    link.click();

                    updateStatus('æ€ç»´å¯¼å›¾å·²å¯¼å‡ºä¸ºå›¾ç‰‡', 'success');
                };

                img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));

            } catch (error) {
                console.error('å¯¼å‡ºå›¾ç‰‡å¤±è´¥:', error);
                updateStatus('å¯¼å‡ºå›¾ç‰‡å¤±è´¥', 'error');
            }
        }
    </script>
</body>
</html>
